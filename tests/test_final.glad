PRINTLN "=== COMPREHENSIVE FINAL & SCOPE TEST ==="
PRINTLN ""

PRINTLN "--- Test 1: Valid Constant Usage ---"
FINAL pi = 3.14159
PRINTLN "Constant 'pi' created: " + pi
LET radius = 5
LET area = pi * (radius ** 2)
PRINTLN "Area calculation result: " + area


PRINTLN ""
PRINTLN "--- Test 2: Simple Reassignment Check ---"
TRY
    PRINTLN "Attempting: LET pi = 3.0"
    LET pi = 3.0
    PRINTLN "FAIL: Interpreter did not stop reassignment!"
CATCH e
    PRINTLN "SUCCESS: Caught error: " + e
ENDTRY


PRINTLN ""
PRINTLN "--- Test 3: Loophole - Array Destructuring ---"
TRY
    PRINTLN "Attempting: LET [pi] = [100]"
    LET [pi] = [100]
    PRINTLN "FAIL: Interpreter did not stop destructuring assignment!"
CATCH e
    PRINTLN "SUCCESS: Caught error: " + e
ENDTRY


PRINTLN ""
PRINTLN "--- Test 4: Loophole - For Loop Iterator ---"
TRY
    PRINTLN "Attempting: FOR pi IN [1, 2, 3] ..."
    FOR pi IN [1, 2, 3]
        PRINTLN "Loop running..."
    ENDFOR
    PRINTLN "FAIL: Interpreter did not stop for-loop overwrite!"
CATCH e
    PRINTLN "SUCCESS: Caught error: " + e
ENDTRY


PRINTLN ""
PRINTLN "--- Test 5: Loophole - List Comprehension ---"
TRY
    PRINTLN "Attempting: [x FOR pi IN [1, 2]]"
    LET list = [x FOR pi IN [1, 2]]
    PRINTLN "FAIL: Interpreter did not stop comprehension overwrite!"
CATCH e
    PRINTLN "SUCCESS: Caught error: " + e
ENDTRY


PRINTLN ""
PRINTLN "--- Test 6: Loophole - Re-declaration ---"
TRY
    PRINTLN "Attempting: FINAL pi = 0.0"
    FINAL pi = 0.0
    PRINTLN "FAIL: Interpreter did not stop re-declaration!"
CATCH e
    PRINTLN "SUCCESS: Caught error: " + e
ENDTRY


PRINTLN ""
PRINTLN "--- Test 7: Loophole - Increment Operator (++) ---"
TRY
    PRINTLN "Attempting: pi++"
    pi++
    PRINTLN "FAIL: Interpreter did not stop incrementing a constant!"
CATCH e
    PRINTLN "SUCCESS: Caught error: " + e
ENDTRY


PRINTLN ""
PRINTLN "--- Test 8: Bug Fix - Global Scope Update ---"
LET count = 0
PRINTLN "Global count starts at: " + count

DEF increment_count()
    # This should update the GLOBAL variable, not create a local one
    count++
ENDDEF

PRINTLN "Calling function increment_count()..."
increment_count()
PRINTLN "Global count is now: " + count

IF count == 1 THEN
    PRINTLN "SUCCESS: Global variable updated correctly."
ENDIF
IF NOT count == 1 THEN
    PRINTLN "FAIL: Global variable did not change (Scope bug exists)."
ENDIF


PRINTLN ""
PRINTLN "--- Final Integrity Check ---"
PRINTLN "Value of 'pi' should still be 3.14159: " + pi